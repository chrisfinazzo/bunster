---
cases:
  - name: "simple `for` loop"
    args: ["foo", "bar", "baz"]
    script: |
      # over positional
      for arg; do
        echo positional: $arg
      done

      for arg in boo boz fee; do
        echo inline: $arg
      done
    expect:
      stdout: |
        positional: foo
        positional: bar
        positional: baz
        inline: boo
        inline: boz
        inline: fee

  - name: "redirections on the `for` loop"
    args: ["foo", "bar", "baz"]
    script: |
      for arg; do
          cat
          echo error >&2
          echo alternative output >&3
      done <<<"Hello World" >output.txt 2>error.txt 3>alternate.txt
    expect:
      files:
        output.txt: "Hello World\n"
        error.txt: |
          error
          error
          error
        alternate.txt: |
          alternative output
          alternative output
          alternative output

  - name: "`for` loop within pipeline"
    args: ["foo", "bar", "baz"]
    script: |
      for arg; do
        echo positional: $arg
      done   |  cat

      for arg in boo boz fee; do
          echo inline: $arg
          cat
      done |  cat
    expect:
      stdout: |
        positional: foo
        positional: bar
        positional: baz
        inline: boo
        inline: boz
        inline: fee

  - name: "`for` loop within list"
    args: ["foo", "bar", "baz"]
    script: |
      for arg; do
        echo positional: $arg
      done   &&

        for arg in boo boz fee; do
          echo inline: $arg
        done
    expect:
      stdout: |
        positional: foo
        positional: bar
        positional: baz
        inline: boo
        inline: boz
        inline: fee

  - name: "break and continue within `for` loop"
    args: ["foo", "bar", "baz"]
    script: |
      for arg; do
        echo before 1
        continue
        echo after 1
      done

      for arg; do
        echo before 2
        break
        echo after 2
      done

      for arg in foo bar baz; do
        echo before 3
        continue
        echo after 3
      done

      for arg in foo bar baz; do
        echo before 4
        break
        echo after 4
      done
    expect:
      stdout: |
        before 1
        before 1
        before 1
        before 2
        before 3
        before 3
        before 3
        before 4

  - name: "simple `for((...))` loop"
    script: |
      for (( i = 0; i < 5; i++ )) do
        echo $i
      done
    expect:
      stdout: |
        0
        1
        2
        3
        4

  - name: "`for((...))` without init branch"
    script: |
      for (( ; i < 5; i++ )) do
        echo $i
      done
    expect:
      stdout: |

        1
        2
        3
        4

  - name: "`for((...))` with init branch only"
    script: |
      for (( i=0 ; ; )) do
        echo $i

        (( i >= 5 )) && break || (( i++ )) 
      done
    expect:
      stdout: |
        0
        1
        2
        3
        4
        5

  - name: "`for((...))` without update branch"
    script: |
      for (( i = 0; i < 5; )) do
        echo $i

        (( i++ ))
      done
    expect:
      stdout: |
        0
        1
        2
        3
        4

  - name: "`for((...))` with update branch only"
    script: |
      let i=0

      for (( ; ; i++ )) do
        echo $i
        (( i >= 5 )) && break
       done
    expect:
      stdout: |
        0
        1
        2
        3
        4
        5

  - name: "`for((...))` without test branch"
    script: |
      for (( i = 0; ; i++ )) do
        echo $i

        (( i >= 5 )) && break
      done
    expect:
      stdout: |
        0
        1
        2
        3
        4
        5

  - name: "`for((...))` with test branch only"
    script: |
      let i = 0
      for (( ; i <= 5; )) do
        echo $i

        (( i++ ))
      done
    expect:
      stdout: |
        0
        1
        2
        3
        4
        5

  - name: "`for((...))` without any branches"
    script: |
      let i = 1

      for (( ; ; )) do
        echo $i

        (( i >= 5 )) && break || (( i++ )) 
      done
    expect:
      stdout: |
        1
        2
        3
        4
        5

  - name: "`for((...))` can accept redirections"
    script: |
      for (( i=0 ; i<5; i++)) do
        echo $i
      done >output.txt
    expect:
      files:
        output.txt: |
          0
          1
          2
          3
          4

  - name: "`for((...))` can be used within pipeline"
    script: |
      for (( i=0 ; i<5; i++)) do
        echo $i
      done | cat
    expect:
      stdout: |
        0
        1
        2
        3
        4

  - name: "`for((...))` exit code is the last command's exit code"
    script: |
      for (( i=0 ; i<5; i++)) do
        true
      done 
      echo $?


      for (( i=0 ; i<5; i++)) do
        false
      done 
      echo $?
    expect:
      stdout: |
        0
        1

  - name: "`for((...))` heeader does not affect exit code"
    script: |
      for (( 0 ; 0; 0)) do
        false
      done
    expect:
      exit_code: 0

  - name: "`for((...))` can have 'continue'"
    script: |
      for (( i=0 ; i < 3; i++)) do
        echo start:$i
        continue
        echo end:$i
      done
    expect:
      stdout: |
        start:0
        start:1
        start:2

  - name: "`continue` cannot be used outside loops"
    script: |
      continue
    expect:
      build_error: "main.sh(0:0): semantic error: the `continue` keyword cannot be used here."

  - name: "`break` cannot be used outside loops"
    script: |
      break
    expect:
      build_error: "main.sh(0:0): semantic error: the `break` keyword cannot be used here."

  - name: "`continue`  must be exactly in the scope of loops"
    script: |
      while true; do
        (continue)
      done
    expect:
      build_error: "main.sh(0:0): semantic error: the `continue` keyword cannot be used here."

  - name: "`break`  must be exactly in the scope of loops"
    script: |
      while true; do
        (break)
      done
    expect:
      build_error: "main.sh(0:0): semantic error: the `break` keyword cannot be used here."
