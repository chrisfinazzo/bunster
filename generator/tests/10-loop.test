
#(TEST: simple `for` loop)

for arg; do
    echo $arg
done

#(RESULT)
package main

import "github.com/yassinebenaid/bunster/runtime"

func Main(shell *runtime.Shell, streamManager *runtime.StreamManager) {
	defer shell.Terminate(streamManager)
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		for _, member := range shell.Args {
			shell.SetVar("arg", member)
			func() {
				streamManager := streamManager.Clone()
				defer streamManager.Destroy()
				var commandName = "echo"
				var arguments []string
				var env = make(map[string]string)
				arguments = append(arguments, shell.ReadVar("arg"))
				if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
					shell.HandleError(streamManager, err)
					return
				}

			}()
		}

	}()
}


#(ENDTEST)



#(TEST: simple `for` loop over operands)

for arg in foo bar baz; do
    echo $arg
done

#(RESULT)
package main

import "github.com/yassinebenaid/bunster/runtime"

func Main(shell *runtime.Shell, streamManager *runtime.StreamManager) {
	defer shell.Terminate(streamManager)
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var members []string
		members = append(members, "foo")
		members = append(members, "bar")
		members = append(members, "baz")
		for _, member := range members {
			shell.SetVar("arg", member)
			func() {
				streamManager := streamManager.Clone()
				defer streamManager.Destroy()
				var commandName = "echo"
				var arguments []string
				var env = make(map[string]string)
				arguments = append(arguments, shell.ReadVar("arg"))
				if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
					shell.HandleError(streamManager, err)
					return
				}

			}()
		}

	}()
}

#(ENDTEST)



#(TEST: redirections on `for` loops)

for arg; do
    echo $arg
done >file.txt <input.txt

#(RESULT)
package main

import "github.com/yassinebenaid/bunster/runtime"

func Main(shell *runtime.Shell, streamManager *runtime.StreamManager) {
	defer shell.Terminate(streamManager)
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		stream0, err := streamManager.OpenStream(shell.Path("file.txt"), runtime.STREAM_FLAG_WRITE)
		if err != nil {
			shell.HandleError(streamManager, err)
			return
		}
		streamManager.Add("1", stream0)
		stream1, err := streamManager.OpenStream(shell.Path("input.txt"), runtime.STREAM_FLAG_READ)
		if err != nil {
			shell.HandleError(streamManager, err)
			return
		}
		streamManager.Add("0", stream1)
		for _, member := range shell.Args {
			shell.SetVar("arg", member)
			func() {
				streamManager := streamManager.Clone()
				defer streamManager.Destroy()
				var commandName = "echo"
				var arguments []string
				var env = make(map[string]string)
				arguments = append(arguments, shell.ReadVar("arg"))
				if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
					shell.HandleError(streamManager, err)
					return
				}

			}()
		}

	}()
}


#(ENDTEST)


