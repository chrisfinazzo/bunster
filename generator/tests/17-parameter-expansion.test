#(TEST: simple parameter expansion)

${varname}
${#varname}

${varname:-}
${varname:-word}
${varname-word}
${varname-}

${varname:=}
${varname:=word}
${varname=word}
${varname=}

${varname:+}
${varname:+word}
${varname+word}
${varname+}

${varname:3}
${varname:3:8}

${varname^}
${varname^word}
${varname^^word}
${varname^^}


${varname,}
${varname,word}
${varname,,word}
${varname,,}

${varname#}
${varname#word}
${varname##word}
${varname##}

${varname%}
${varname%word}
${varname%%word}
${varname%%}

${varname/}
${varname/pattern}
${varname/pattern/word}
${varname//}
${varname//pattern}
${varname//pattern/word}
${varname/#}
${varname/#pattern}
${varname/#pattern/word}
${varname/%}
${varname/%pattern}
${varname/%pattern/word}
#(RESULT)

package main

import "github.com/yassinebenaid/bunster/runtime"

func Main(shell *runtime.Shell, streamManager *runtime.StreamManager) {
	defer shell.Terminate(streamManager)
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = shell.ReadVar("varname")
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.FormatInt(len([]rune(shell.ReadVar("varname"))))
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var expr3 = ""
		if len(shell.ReadVar("varname")) != 0 {
			expr3 = shell.ReadVar("varname")
		} else {
			expr3 = ""
		}
		var commandName = expr3
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var expr4 = ""
		if len(shell.ReadVar("varname")) != 0 {
			expr4 = shell.ReadVar("varname")
		} else {
			expr4 = "word"
		}
		var commandName = expr4
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var expr6 = ""
		if shell.VarIsSet("varname") {
			expr6 = shell.ReadVar("varname")
		} else {
			expr6 = "word"
		}
		var commandName = expr6
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var expr8 = ""
		if shell.VarIsSet("varname") {
			expr8 = shell.ReadVar("varname")
		} else {
			expr8 = ""
		}
		var commandName = expr8
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		if !(len(shell.ReadVar("varname")) != 0) {
			shell.SetVar("varname", "")
		}
		var commandName = shell.ReadVar("varname")
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		if !(len(shell.ReadVar("varname")) != 0) {
			shell.SetVar("varname", "word")
		}
		var commandName = shell.ReadVar("varname")
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		if !(shell.VarIsSet("varname")) {
			shell.SetVar("varname", "word")
		}
		var commandName = shell.ReadVar("varname")
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		if !(shell.VarIsSet("varname")) {
			shell.SetVar("varname", "")
		}
		var commandName = shell.ReadVar("varname")
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var expr15 = ""
		if len(shell.ReadVar("varname")) != 0 {
			expr15 = ""
		}
		var commandName = expr15
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var expr16 = ""
		if len(shell.ReadVar("varname")) != 0 {
			expr16 = "word"
		}
		var commandName = expr16
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var expr18 = ""
		if shell.VarIsSet("varname") {
			expr18 = "word"
		}
		var commandName = expr18
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var expr20 = ""
		if shell.VarIsSet("varname") {
			expr20 = ""
		}
		var commandName = expr20
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var offset21 = 0
		var length21 = int(^uint32(0))
		offset21 = 3
		var commandName = runtime.Substring(shell.ReadVar("varname"), offset21, length21)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var offset22 = 0
		var length22 = int(^uint32(0))
		offset22 = 3
		length22 = 8
		var commandName = runtime.Substring(shell.ReadVar("varname"), offset22, length22)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ChangeStringCase(true, shell.ReadVar("varname"), "?", false)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ChangeStringCase(true, shell.ReadVar("varname"), "word", false)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ChangeStringCase(true, shell.ReadVar("varname"), "word", true)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ChangeStringCase(true, shell.ReadVar("varname"), "?", true)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ChangeStringCase(false, shell.ReadVar("varname"), "?", false)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ChangeStringCase(false, shell.ReadVar("varname"), "word", false)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ChangeStringCase(false, shell.ReadVar("varname"), "word", true)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ChangeStringCase(false, shell.ReadVar("varname"), "?", true)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.RemoveMatchingPrefix(shell.ReadVar("varname"), "", false)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.RemoveMatchingPrefix(shell.ReadVar("varname"), "word", false)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.RemoveMatchingPrefix(shell.ReadVar("varname"), "word", true)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.RemoveMatchingPrefix(shell.ReadVar("varname"), "", true)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.RemoveMatchingSuffix(shell.ReadVar("varname"), "", false)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.RemoveMatchingSuffix(shell.ReadVar("varname"), "word", false)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.RemoveMatchingSuffix(shell.ReadVar("varname"), "word", true)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.RemoveMatchingSuffix(shell.ReadVar("varname"), "", true)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ReplaceMatching(shell.ReadVar("varname"), "", "", false)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ReplaceMatching(shell.ReadVar("varname"), "pattern", "", false)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ReplaceMatching(shell.ReadVar("varname"), "pattern", "word", false)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ReplaceMatching(shell.ReadVar("varname"), "", "", true)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ReplaceMatching(shell.ReadVar("varname"), "pattern", "", true)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ReplaceMatching(shell.ReadVar("varname"), "pattern", "word", true)
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ReplaceMatchingPrefix(shell.ReadVar("varname"), "", "")
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ReplaceMatchingPrefix(shell.ReadVar("varname"), "pattern", "")
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ReplaceMatchingPrefix(shell.ReadVar("varname"), "pattern", "word")
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ReplaceMatchingSuffix(shell.ReadVar("varname"), "", "")
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ReplaceMatchingSuffix(shell.ReadVar("varname"), "pattern", "")
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = runtime.ReplaceMatchingSuffix(shell.ReadVar("varname"), "pattern", "word")
		var arguments []string
		var env = make(map[string]string)
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
}


#(ENDTEST)



#(TEST: positional parameter expansion)


echo ${123} \
	${#123} \
	${123:-} \
	${123:-word} \
	${123-word} \
	${123-} \
\
	${123:+} \
	${123:+word} \
	${123+word} \
	${123+} \
\
	${123:3} \
	${123:3:8} \
\
	${123^} \
	${123^word} \
	${123^^word} \
	${123^^} \
\
	${123,} \
	${123,word} \
	${123,,word} \
	${123,,} \
\
	${123#} \
	${123#word} \
	${123##word} \
	${123##} \
\
	${123%} \
	${123%word} \
	${123%%word} \
	${123%%} \
\
	${123/} \
	${123/pattern} \
	${123/pattern/word} \
	${123//} \
	${123//pattern} \
	${123//pattern/word} \
	${123/#} \
	${123/#pattern} \
	${123/#pattern/word} \
	${123/%} \
	${123/%pattern} \
	${123/%pattern/word}
	
#(RESULT)
package main

import "github.com/yassinebenaid/bunster/runtime"

func Main(shell *runtime.Shell, streamManager *runtime.StreamManager) {
	defer shell.Terminate(streamManager)
	func() {
		streamManager := streamManager.Clone()
		defer streamManager.Destroy()
		var commandName = "echo"
		var arguments []string
		var env = make(map[string]string)
		arguments = append(arguments, shell.ReadSpecialVar("123"))
		arguments = append(arguments, runtime.FormatInt(len([]rune(shell.ReadSpecialVar("123")))))
		var expr4 = ""
		if len(shell.ReadSpecialVar("123")) != 0 {
			expr4 = shell.ReadSpecialVar("123")
		} else {
			expr4 = ""
		}
		arguments = append(arguments, expr4)
		var expr5 = ""
		if len(shell.ReadSpecialVar("123")) != 0 {
			expr5 = shell.ReadSpecialVar("123")
		} else {
			expr5 = "word"
		}
		arguments = append(arguments, expr5)
		var expr7 = ""
		if 123 <= len(shell.Args) {
			expr7 = shell.ReadSpecialVar("123")
		} else {
			expr7 = "word"
		}
		arguments = append(arguments, expr7)
		var expr9 = ""
		if 123 <= len(shell.Args) {
			expr9 = shell.ReadSpecialVar("123")
		} else {
			expr9 = ""
		}
		arguments = append(arguments, expr9)
		var expr10 = ""
		if len(shell.ReadSpecialVar("123")) != 0 {
			expr10 = ""
		}
		arguments = append(arguments, expr10)
		var expr11 = ""
		if len(shell.ReadSpecialVar("123")) != 0 {
			expr11 = "word"
		}
		arguments = append(arguments, expr11)
		var expr13 = ""
		if 123 <= len(shell.Args) {
			expr13 = "word"
		}
		arguments = append(arguments, expr13)
		var expr15 = ""
		if 123 <= len(shell.Args) {
			expr15 = ""
		}
		arguments = append(arguments, expr15)
		var offset16 = 0
		var length16 = int(^uint32(0))
		offset16 = 3
		arguments = append(arguments, runtime.Substring(shell.ReadSpecialVar("123"), offset16, length16))
		var offset17 = 0
		var length17 = int(^uint32(0))
		offset17 = 3
		length17 = 8
		arguments = append(arguments, runtime.Substring(shell.ReadSpecialVar("123"), offset17, length17))
		arguments = append(arguments, runtime.ChangeStringCase(true, shell.ReadSpecialVar("123"), "?", false))
		arguments = append(arguments, runtime.ChangeStringCase(true, shell.ReadSpecialVar("123"), "word", false))
		arguments = append(arguments, runtime.ChangeStringCase(true, shell.ReadSpecialVar("123"), "word", true))
		arguments = append(arguments, runtime.ChangeStringCase(true, shell.ReadSpecialVar("123"), "?", true))
		arguments = append(arguments, runtime.ChangeStringCase(false, shell.ReadSpecialVar("123"), "?", false))
		arguments = append(arguments, runtime.ChangeStringCase(false, shell.ReadSpecialVar("123"), "word", false))
		arguments = append(arguments, runtime.ChangeStringCase(false, shell.ReadSpecialVar("123"), "word", true))
		arguments = append(arguments, runtime.ChangeStringCase(false, shell.ReadSpecialVar("123"), "?", true))
		arguments = append(arguments, runtime.RemoveMatchingPrefix(shell.ReadSpecialVar("123"), "", false))
		arguments = append(arguments, runtime.RemoveMatchingPrefix(shell.ReadSpecialVar("123"), "word", false))
		arguments = append(arguments, runtime.RemoveMatchingPrefix(shell.ReadSpecialVar("123"), "word", true))
		arguments = append(arguments, runtime.RemoveMatchingPrefix(shell.ReadSpecialVar("123"), "", true))
		arguments = append(arguments, runtime.RemoveMatchingSuffix(shell.ReadSpecialVar("123"), "", false))
		arguments = append(arguments, runtime.RemoveMatchingSuffix(shell.ReadSpecialVar("123"), "word", false))
		arguments = append(arguments, runtime.RemoveMatchingSuffix(shell.ReadSpecialVar("123"), "word", true))
		arguments = append(arguments, runtime.RemoveMatchingSuffix(shell.ReadSpecialVar("123"), "", true))
		arguments = append(arguments, runtime.ReplaceMatching(shell.ReadSpecialVar("123"), "", "", false))
		arguments = append(arguments, runtime.ReplaceMatching(shell.ReadSpecialVar("123"), "pattern", "", false))
		arguments = append(arguments, runtime.ReplaceMatching(shell.ReadSpecialVar("123"), "pattern", "word", false))
		arguments = append(arguments, runtime.ReplaceMatching(shell.ReadSpecialVar("123"), "", "", true))
		arguments = append(arguments, runtime.ReplaceMatching(shell.ReadSpecialVar("123"), "pattern", "", true))
		arguments = append(arguments, runtime.ReplaceMatching(shell.ReadSpecialVar("123"), "pattern", "word", true))
		arguments = append(arguments, runtime.ReplaceMatchingPrefix(shell.ReadSpecialVar("123"), "", ""))
		arguments = append(arguments, runtime.ReplaceMatchingPrefix(shell.ReadSpecialVar("123"), "pattern", ""))
		arguments = append(arguments, runtime.ReplaceMatchingPrefix(shell.ReadSpecialVar("123"), "pattern", "word"))
		arguments = append(arguments, runtime.ReplaceMatchingSuffix(shell.ReadSpecialVar("123"), "", ""))
		arguments = append(arguments, runtime.ReplaceMatchingSuffix(shell.ReadSpecialVar("123"), "pattern", ""))
		arguments = append(arguments, runtime.ReplaceMatchingSuffix(shell.ReadSpecialVar("123"), "pattern", "word"))
		if err := shell.Exec(streamManager, commandName, arguments, env); err != nil {
			shell.HandleError(streamManager, err)
			return
		}

	}()
}

#(ENDTEST)