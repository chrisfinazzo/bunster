#(TEST: simple pipeline)
cat file.txt | grep foobar
#(RESULT)
package main

import "bunster-build/runtime"

func Main(shell *runtime.Shell) {
	func() {
		var pipeline_waitgroup runtime.PiplineWaitgroup
		pipe_1_reader, pipe_1_writer, err := runtime.NewPipe()
		if err != nil {
			shell.HandleError("", err)
			return
		}
		func() {
			var commandName = `cat`
			var arguments []string
			arguments = append(arguments, `file.txt`)
			var command = shell.Command(commandName, arguments...)
			command_fdt, err := shell.CloneFDT()
			if err != nil {
				shell.HandleError("", err)
				return
			}
			defer command_fdt.Destroy()
			command_fdt.Add(`1`, pipe_1_writer)
			command.Stdin = command_fdt.Get(`0`)
			command.Stdout = command_fdt.Get(`1`)
			command.Stderr = command_fdt.Get(`2`)
			if err := command.Start(); err != nil {
				shell.HandleError(commandName, err)
				return
			}
			pipeline_waitgroup = append(pipeline_waitgroup, runtime.PiplineWaitgroupItem{
				Wait: command.Wait,
			})
		}()
		func() {
			var commandName = `grep`
			var arguments []string
			arguments = append(arguments, `foobar`)
			var command = shell.Command(commandName, arguments...)
			command_fdt, err := shell.CloneFDT()
			if err != nil {
				shell.HandleError("", err)
				return
			}
			defer command_fdt.Destroy()
			command_fdt.Add(`0`, pipe_1_reader)
			command.Stdin = command_fdt.Get(`0`)
			command.Stdout = command_fdt.Get(`1`)
			command.Stderr = command_fdt.Get(`2`)
			if err := command.Start(); err != nil {
				shell.HandleError(commandName, err)
				return
			}
			pipeline_waitgroup = append(pipeline_waitgroup, runtime.PiplineWaitgroupItem{
				Wait: command.Wait,
			})
		}()
		for i, item := range pipeline_waitgroup {
			if err := item.Wait(); err != nil {
				shell.HandleError("", err)
			}
			if i < (len(pipeline_waitgroup) - 1) {
				shell.ExitCode = 0
			}
		}

	}()
}

#(ENDTEST)


#(TEST: longer pipeline)

cat file.txt |
    grep foobar |
    strep "[o]+" "o" |
    strjoin ', '

#(RESULT)
package main

import "bunster-build/runtime"

func Main(shell *runtime.Shell) {
	func() {
		var pipeline_waitgroup runtime.PiplineWaitgroup
		pipe_1_reader, pipe_1_writer, err := runtime.NewPipe()
		if err != nil {
			shell.HandleError("", err)
			return
		}
		func() {
			var commandName = `cat`
			var arguments []string
			arguments = append(arguments, `file.txt`)
			var command = shell.Command(commandName, arguments...)
			command_fdt, err := shell.CloneFDT()
			if err != nil {
				shell.HandleError("", err)
				return
			}
			defer command_fdt.Destroy()
			command_fdt.Add(`1`, pipe_1_writer)
			command.Stdin = command_fdt.Get(`0`)
			command.Stdout = command_fdt.Get(`1`)
			command.Stderr = command_fdt.Get(`2`)
			if err := command.Start(); err != nil {
				shell.HandleError(commandName, err)
				return
			}
			pipeline_waitgroup = append(pipeline_waitgroup, runtime.PiplineWaitgroupItem{
				Wait: command.Wait,
			})
		}()
		pipe_2_reader, pipe_2_writer, err := runtime.NewPipe()
		if err != nil {
			shell.HandleError("", err)
			return
		}
		func() {
			var commandName = `grep`
			var arguments []string
			arguments = append(arguments, `foobar`)
			var command = shell.Command(commandName, arguments...)
			command_fdt, err := shell.CloneFDT()
			if err != nil {
				shell.HandleError("", err)
				return
			}
			defer command_fdt.Destroy()
			command_fdt.Add(`1`, pipe_2_writer)
			command_fdt.Add(`0`, pipe_1_reader)
			command.Stdin = command_fdt.Get(`0`)
			command.Stdout = command_fdt.Get(`1`)
			command.Stderr = command_fdt.Get(`2`)
			if err := command.Start(); err != nil {
				shell.HandleError(commandName, err)
				return
			}
			pipeline_waitgroup = append(pipeline_waitgroup, runtime.PiplineWaitgroupItem{
				Wait: command.Wait,
			})
		}()
		pipe_3_reader, pipe_3_writer, err := runtime.NewPipe()
		if err != nil {
			shell.HandleError("", err)
			return
		}
		func() {
    		var commandName = `strep`
    		var arguments []string
            arguments = append(arguments, `[o]+`)
            arguments = append(arguments, `o`)
    		var command = shell.Command(commandName, arguments...)
    		command_fdt, err := shell.CloneFDT()
    		if err != nil {
    			shell.HandleError("", err)
    			return
    		}
    		defer command_fdt.Destroy()
    		command_fdt.Add(`1`, pipe_3_writer)
			command_fdt.Add(`0`, pipe_2_reader)
    		command.Stdin = command_fdt.Get(`0`)
    		command.Stdout = command_fdt.Get(`1`)
    		command.Stderr = command_fdt.Get(`2`)
    		if err := command.Start(); err != nil {
    			shell.HandleError(commandName, err)
    			return
    		}
    		pipeline_waitgroup = append(pipeline_waitgroup, runtime.PiplineWaitgroupItem{
    			Wait: command.Wait,
		})
		}()
			func() {
			var commandName = `strjoin`
			var arguments []string
			arguments = append(arguments, `, `)
			var command = shell.Command(commandName, arguments...)
			command_fdt, err := shell.CloneFDT()
			if err != nil {
				shell.HandleError("", err)
				return
			}
			defer command_fdt.Destroy()
			command_fdt.Add(`0`, pipe_3_reader)
			command.Stdin = command_fdt.Get(`0`)
			command.Stdout = command_fdt.Get(`1`)
			command.Stderr = command_fdt.Get(`2`)
			if err := command.Start(); err != nil {
				shell.HandleError(commandName, err)
				return
			}
			pipeline_waitgroup = append(pipeline_waitgroup, runtime.PiplineWaitgroupItem{
				Wait: command.Wait,
			})
		}()
		for i, item := range pipeline_waitgroup {
			if err := item.Wait(); err != nil {
				shell.HandleError("", err)
			}
			if i < (len(pipeline_waitgroup) - 1) {
				shell.ExitCode = 0
			}
		}

	}()
}

#(ENDTEST)


#(TEST: pipeline that redirects stderr as well)
cat file.txt |& grep foobar
#(RESULT)
package main

import "bunster-build/runtime"

func Main(shell *runtime.Shell) {
	func() {
		var pipeline_waitgroup runtime.PiplineWaitgroup
		pipe_1_reader, pipe_1_writer, err := runtime.NewPipe()
		if err != nil {
			shell.HandleError("", err)
			return
		}
		func() {
			var commandName = `cat`
			var arguments []string
			arguments = append(arguments, `file.txt`)
			var command = shell.Command(commandName, arguments...)
			command_fdt, err := shell.CloneFDT()
			if err != nil {
				shell.HandleError("", err)
				return
			}
			defer command_fdt.Destroy()
			command_fdt.Add(`1`, pipe_1_writer)
			command_fdt.Add(`2`, pipe_1_writer)
			command.Stdin = command_fdt.Get(`0`)
			command.Stdout = command_fdt.Get(`1`)
			command.Stderr = command_fdt.Get(`2`)
			if err := command.Start(); err != nil {
				shell.HandleError(commandName, err)
				return
			}
			pipeline_waitgroup = append(pipeline_waitgroup, runtime.PiplineWaitgroupItem{
				Wait: command.Wait,
			})
		}()
		func() {
			var commandName = `grep`
			var arguments []string
			arguments = append(arguments, `foobar`)
			var command = shell.Command(commandName, arguments...)
			command_fdt, err := shell.CloneFDT()
			if err != nil {
				shell.HandleError("", err)
				return
			}
			defer command_fdt.Destroy()
			command_fdt.Add(`0`, pipe_1_reader)
			command.Stdin = command_fdt.Get(`0`)
			command.Stdout = command_fdt.Get(`1`)
			command.Stderr = command_fdt.Get(`2`)
			if err := command.Start(); err != nil {
				shell.HandleError(commandName, err)
				return
			}
			pipeline_waitgroup = append(pipeline_waitgroup, runtime.PiplineWaitgroupItem{
				Wait: command.Wait,
			})
		}()
		for i, item := range pipeline_waitgroup {
			if err := item.Wait(); err != nil {
				shell.HandleError("", err)
			}
			if i < (len(pipeline_waitgroup) - 1) {
				shell.ExitCode = 0
			}
		}

	}()
}

#(ENDTEST)
